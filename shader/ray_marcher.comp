#version 460

#extension GL_EXT_shader_8bit_storage : enable

layout(local_size_x = 32, local_size_y = 32) in;

struct PixelData {
    vec3 col;
};

struct CameraData
{
    vec3 pos;
    vec3 u;
    vec3 v;
    vec3 w;
};

struct Ray
{
    vec3 origin;
    vec3 dir;
};

layout(constant_id = 0) const uint volume_width = 1;
layout(constant_id = 1) const uint volume_height = 1;
layout(constant_id = 2) const uint volume_depth = 1;

layout(binding = 0) readonly buffer Volume { uint8_t data[]; };
layout(binding = 1) readonly buffer TransferFunctionBuffer { vec4 transfer_function[]; };
layout(binding = 2) uniform UniformBuffer { CameraData camera_data; };
layout(binding = 3, rgba8) uniform restrict writeonly image2D output_image;
layout(binding = 4) readonly buffer InputPixelBuffer { PixelData input_pixel_data[]; };
layout(binding = 5) writeonly buffer OutputPixelBuffer { PixelData output_pixel_data[]; };

float compMax(vec3 v)
{
    return max(max(v.x, v.y), v.z);
}

float compMin(vec3 v)
{
    return min(min(v.x, v.y), v.z);
}

bool intersect(vec3 origin, vec3 dir, out float out_t)
{
    // ray tracing gems II
    vec3 t_lower = (vec3(-1.0) - origin) / dir;
    vec3 t_upper = (vec3(1.0) - origin) / dir;
    // the four t-intervals (for x-/y-/z-slabs, and ray p(t))
    vec3 t_mins = min(t_lower, t_upper);
    vec3 t_maxes = max(t_lower, t_upper);
    float t_box_min = max(compMax(t_mins), 0.0f);
    float t_box_max = min(compMin(t_maxes), 1000.0f);
    out_t = t_box_min;
    return t_box_min <= t_box_max;
}

vec3 ray_march(Ray ray)
{
    float t;
    float step_size = 0.01;
    bool hit = intersect(ray.origin, ray.dir, t);

    vec3 accumulated_color = vec3(0.0, 0.0, 0.0);
    float accumulated_alpha = 0.0;

    for (uint i = 0; hit && i < 200; i++)
    {
        vec3 pos = ray.origin + (t + 0.0001) * ray.dir;
        bool in_bounds = all(greaterThanEqual(pos, vec3(-1.0))) && all(lessThanEqual(pos, vec3(1.0)));

        // scale position to volume coordinates
        uvec3 volume_pos = uvec3((pos + 1.0) * 0.5 * vec3(volume_width, volume_height, volume_depth));

        // left the volume -> done
        if (!in_bounds) break;

        uint index = uint(volume_pos.z) * volume_height * volume_width + uint(volume_pos.y) * volume_width + uint(volume_pos.x);
        float density = (length(pos) > 1.0 || length(pos.xy) < 0.5) ? -1.0 : 0.5;//float(uint(data[index])) / 255.0;

        if (density > 0.0) 
        { 
            //vec4 tf_value = transfer_function[int(density * (transfer_function.length() - 1))];

            /*if (density > 0.65) {
                accumulated_color = vec3(0.0, 1.0, 0.0);  // red high 
            } else if (density > 0.4) {
                accumulated_color = vec3(1.0, 0.0, 0.0); // green middle
            } else {
                accumulated_color = vec3(1.0, 0.0, 1.0); // pink middle
            }*/
            
            uint tf_index = uint(density * (transfer_function.length()));
            tf_index = clamp(tf_index, 0, transfer_function.length() - 1);
            vec4 tf_value = transfer_function[tf_index];

            float alpha = tf_value.a * step_size;
            vec3 voxel_color = tf_value.rgb; 

            // Pre-multiply alpha to the voxel color
            vec3 pre_multiplied_color = voxel_color * alpha;

            accumulated_color += pre_multiplied_color * (1.0 - accumulated_alpha);
            accumulated_alpha += alpha * (1.0 - accumulated_alpha);

            // Accumulate color and alpha
            //accumulated_color = mix(accumulated_color, voxel_color, alpha * (1.0 - accumulated_alpha));
            //accumulated_alpha += alpha * (1.0 - accumulated_alpha);

            if (accumulated_alpha >= 1.0) break;
        }

        t += step_size;
    }
   
   return accumulated_color;
}

Ray get_camera_ray(ivec2 resolution, ivec2 pixel)
{
    vec3 u = camera_data.u;
    vec3 v = camera_data.v;
    vec3 w = camera_data.w;
    vec3 pos = camera_data.pos;

    vec2 pixel_coordinates = vec2(pixel) / vec2(resolution);
    float aspect_ratio = float(resolution.y) / float(resolution.x);
    pixel_coordinates.y *= aspect_ratio;
    pixel_coordinates.y += (1.0 - aspect_ratio) / 2.0;
    pixel_coordinates -= 0.5;
    vec3 pixel_pos = (pixel_coordinates.x * u) - (pixel_coordinates.y * v) - w;
    return Ray(pos, normalize(pixel_pos));
}

void main() 
{
    ivec2 resolution = imageSize(output_image);
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(pixel, resolution))) return;

    Ray ray = get_camera_ray(resolution, pixel);
    vec3 color = ray_march(ray);

    imageStore(output_image, ivec2(pixel), vec4(color, 1.0));

    // write to output pixel buffer
    uint pixel_index = pixel.y * resolution.x + pixel.x;
    output_pixel_data[pixel_index].col = color;
}
