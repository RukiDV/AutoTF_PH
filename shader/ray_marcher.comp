#version 460

#extension GL_EXT_shader_8bit_storage : enable

layout(local_size_x = 32, local_size_y = 32) in;

struct PixelData {
    vec3 col;
};

struct CameraData
{
    vec3 pos;
    vec3 u;
    vec3 v;
    vec3 w;
};

struct Ray
{
    vec3 origin;
    vec3 dir;
};

struct PushConstants
{
    uint display_mode;   // 0 = iso, 1 = volume
    float max_gradient; // maximum gradient value for 2D TF
};

layout(push_constant) uniform DisplayMode { PushConstants pc; };

layout(constant_id = 0) const uint volume_width = 1;
layout(constant_id = 1) const uint volume_height = 1;
layout(constant_id = 2) const uint volume_depth = 1;
layout(constant_id = 3) const uint TF2D_BINS = 256;

layout(binding = 0) readonly buffer Volume { uint8_t volume_data[]; };
layout(binding = 1) readonly buffer TransferFunctionBuffer { vec4 transfer_function[]; };
layout(binding = 2) uniform UniformBuffer { CameraData camera_data; };
layout(binding = 3, rgba8) uniform restrict writeonly image2D output_image;
layout(binding = 4) readonly buffer InputPixelBuffer { PixelData input_pixel_data[]; };
layout(binding = 5) writeonly buffer OutputPixelBuffer { PixelData output_pixel_data[]; };
layout(binding = 6) readonly buffer GradientVolume { uint8_t grad_data[]; };

float compMax(vec3 v)
{
    return max(max(v.x, v.y), v.z);
}

float compMin(vec3 v)
{
    return min(min(v.x, v.y), v.z);
}

bool intersect(vec3 origin, vec3 dir, out float out_t)
{
    // ray tracing gems II
    vec3 t_lower = (vec3(-1.0) - origin) / dir;
    vec3 t_upper = (vec3(1.0) - origin) / dir;
    // the four t-intervals (for x-/y-/z-slabs, and ray p(t))
    vec3 t_mins = min(t_lower, t_upper);
    vec3 t_maxes = max(t_lower, t_upper);
    float t_box_min = max(compMax(t_mins), 0.0f);
    float t_box_max = min(compMin(t_maxes), 1000.0f);
    out_t = t_box_min;
    return t_box_min <= t_box_max;
}

// calculate gradient
float gradient(vec3 pos)
{
    float epsilon = 0.01;

    // calculate density of neighbor points
    float density_x_plus = length((pos + vec3(epsilon, 0.0, 0.0)).xy);
    float density_x_minus = length((pos - vec3(epsilon, 0.0, 0.0)).xy);
    float density_y_plus = length((pos + vec3(0.0, epsilon, 0.0)).xy);
    float density_y_minus = length((pos - vec3(0.0, epsilon, 0.0)).xy);
    float density_z_plus = length((pos + vec3(0.0, 0.0, epsilon)).xy);
    float density_z_minus = length((pos - vec3(0.0, 0.0, epsilon)).xy);

    // calculate derivation
    float grad_x = (density_x_plus - density_x_minus) / (2.0 * epsilon);
    float grad_y = (density_y_plus - density_y_minus) / (2.0 * epsilon);
    float grad_z = (density_z_plus - density_z_minus) / (2.0 * epsilon);

    // calculate abs of gradient
    return sqrt(grad_x * grad_x + grad_y * grad_y + grad_z * grad_z);
}

float trilinear_interpolate(uvec3 volume_pos, vec3 weights) 
{
    vec3 vol_size = vec3(volume_width, volume_height, volume_depth);

    uint index000 = volume_pos.z * volume_height * volume_width + volume_pos.y * volume_width + volume_pos.x;
    uint index100 = index000 + 1;
    uint index010 = index000 + volume_width;
    uint index110 = index010 + 1;
    uint index001 = index000 + volume_width * volume_height;
    uint index101 = index001 + 1;
    uint index011 = index001 + volume_width;
    uint index111 = index011 + 1;

    float c000 = float(uint(volume_data[index000])) / 255.0;
    float c100 = float(uint(volume_data[index100])) / 255.0;
    float c010 = float(uint(volume_data[index010])) / 255.0;
    float c110 = float(uint(volume_data[index110])) / 255.0;
    float c001 = float(uint(volume_data[index001])) / 255.0;
    float c101 = float(uint(volume_data[index101])) / 255.0;
    float c011 = float(uint(volume_data[index011])) / 255.0;
    float c111 = float(uint(volume_data[index111])) / 255.0;

    float c00 = mix(c000, c100, weights.x);
    float c10 = mix(c010, c110, weights.x);
    float c01 = mix(c001, c101, weights.x);
    float c11 = mix(c011, c111, weights.x);

    float c0 = mix(c00, c10, weights.y);
    float c1 = mix(c01, c11, weights.y);

    return mix(c0, c1, weights.z);
}

vec3 ray_march(Ray ray)
{
    float t;
    const float step_size     = 0.001;
    const float highlight_step = 0.001;
    const uint  max_iterations = 2000u;

    bool hit = intersect(ray.origin, ray.dir, t);
    if (!hit)
    {
        return vec3(1.0); // white background on miss
    }

    if (pc.display_mode == 0u)
    {
        // iso-surface mode: single-hit early exit
        for (uint i = 0u; i < max_iterations; ++i)
        {
            vec3 pos = ray.origin + (t + 1e-4) * ray.dir;
            // leave volume?
            if (any(lessThan(pos, vec3(-1.0))) || any(greaterThan(pos, vec3( 1.0))))
            {
                break;
            }

            // sample scalar with trilinear interpolation
            vec3 vf = (pos + 1.0) * 0.5 * vec3(volume_width, volume_height, volume_depth);
            uvec3 p0 = uvec3(floor(vf));
            vec3  weight = fract(vf);
            float density = trilinear_interpolate(p0, weight);

            // lookup transfer function
            uint idx = uint(density * float(transfer_function.length()));
            idx = clamp(idx, 0u, transfer_function.length()-1u);
            vec4 tfv = transfer_function[idx];

            // early exit on first non-zero alpha
            if (tfv.a > 0.0)
            {
                return tfv.rgb;
            }
            t += step_size;
        }
        // no hit = white; but our loop returns as soon as we hit, so reaching here means “missed all” or “exited early”
        return vec3(1.0);

    } else
    {
        // volume-highlight mode: translucent blending
        vec3  accum_color = vec3(0.0);
        float accum_alpha = 0.0;

        for (uint i = 0u; i < max_iterations; ++i)
        {
            vec3 pos = ray.origin + (t + 1e-4) * ray.dir;
            if (any(lessThan(pos, vec3(-1.0))) || any(greaterThan(pos, vec3( 1.0))))
            {
                break;
            }

            vec3 vf = (pos + 1.0) * 0.5 * vec3(volume_width, volume_height, volume_depth);
            uvec3 p0 = uvec3(floor(vf));
            vec3  weight = fract(vf);
            float density = trilinear_interpolate(p0, weight);

            uint idx = uint(density * float(transfer_function.length()));
            idx = clamp(idx, 0u, transfer_function.length()-1u);
            vec4 tfv = transfer_function[idx];

            // accumulate front-to-back blending
            float alpha = tfv.a * highlight_step;
            vec3 pre = tfv.rgb * alpha;
            accum_color += pre * (1.0 - accum_alpha);
            accum_alpha += alpha * (1.0 - accum_alpha);
            if (accum_alpha >= 0.95)
            {
                break;
            }
            t += step_size;
        }
        // composite over white background
        accum_color += (1.0 - accum_alpha) * vec3(1.0);
        return accum_color;
    }
}

Ray get_camera_ray(ivec2 resolution, ivec2 pixel)
{
    vec3 u = camera_data.u;
    vec3 v = camera_data.v;
    vec3 w = camera_data.w;
    vec3 pos = camera_data.pos;

    vec2 pixel_coordinates = vec2(pixel) / vec2(resolution);
    float aspect_ratio = float(resolution.y) / float(resolution.x);
    pixel_coordinates.y *= aspect_ratio;
    pixel_coordinates.y += (1.0 - aspect_ratio) / 2.0;
    pixel_coordinates -= 0.5;
    vec3 pixel_pos = (pixel_coordinates.x * u) - (pixel_coordinates.y * v) - w;
    return Ray(pos, normalize(pixel_pos));
}

bool intersect_line(Ray ray, in vec3 p0, in vec3 p1, float thickness, out float t)
{
    // center the cylinder, normalize axis
    vec3 cc = 0.5 * (p0 + p1);
    float ch = length(p1 - p0);
    vec3 ca = (p1 - p0) / ch;
    ch *= 0.5;

    vec3  oc = ray.origin - cc;

    float card = dot(ca, ray.dir);
    float caoc = dot(ca, oc);
    
    float a = 1.0 - card * card;
    float b = dot( oc, ray.dir) - caoc * card;
    float c = dot( oc, oc) - caoc * caoc - (thickness / 2) * (thickness / 2);
    float h = b * b - a * c;
    if (h < 0.0) return false;
    h = sqrt(h);
    float t1 = (-b - h) / a;
    //float t2 = (-b + h) / a; // exit point

    float y = caoc + t1 * card;

    // body
    if (abs(y) < ch)
    {
        t = t1;
        return true;
    }
    // caps
    float sy = sign(y);
    float tp = (sy * ch - caoc) / card;
    if (abs(b + a * tp) < h)
    {
        t = tp;
        return true;
    }
    return false;
}

void calculate_coord_system(ivec2 resolution, ivec2 pixel, inout vec3 color)
{
    // set coord system in upper left corner
    const vec2 coordinate_vis_size = vec2(resolution.x / 10.0);
    const vec2 lower_coord_vis_pos = resolution / 2.0 - coordinate_vis_size / 2.0;
    const float thickness = 0.02f;
    if (all(lessThanEqual(pixel, coordinate_vis_size)))
    {
        Ray axis_translation_ray = get_camera_ray(resolution, resolution / 2);
        vec3 axis_translation = axis_translation_ray.origin + axis_translation_ray.dir * 10.0;
        vec3 x_axis_begin = axis_translation + vec3(0.02, 0.0, 0.0);
        vec3 y_axis_begin = axis_translation + vec3(0.0, 0.02, 0.0);
        vec3 z_axis_begin = axis_translation + vec3(0.0, 0.0, 0.02);
        vec3 x_axis_end = axis_translation + vec3(0.4, 0.0, 0.0);
        vec3 y_axis_end = axis_translation + vec3(0.0, 0.4, 0.0);
        vec3 z_axis_end = axis_translation + vec3(0.0, 0.0, 0.4);

        Ray coord_vis_ray = get_camera_ray(resolution, ivec2(pixel + lower_coord_vis_pos));
        float tmp_t = 0.0f;
        float t = 100000.0f;
        if (intersect_line(coord_vis_ray, x_axis_begin, x_axis_end, thickness, tmp_t) && tmp_t < t)
        {
            color = vec3(1.0, 0.0, 0.0);
            t = tmp_t;
        }
        if (intersect_line(coord_vis_ray, y_axis_begin, y_axis_end, thickness, tmp_t) && tmp_t < t)
        {
            color = vec3(0.0, 1.0, 0.0);
            t = tmp_t;
        }
        if (intersect_line(coord_vis_ray, z_axis_begin, z_axis_end, thickness, tmp_t) && tmp_t < t)
        {
            color = vec3(0.0, 0.0, 1.0);
            t = tmp_t;
        }
    }
}

void main()
{
    ivec2 resolution = imageSize(output_image);
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(pixel, resolution))) return;

    Ray ray = get_camera_ray(resolution, pixel);
    vec3 color = ray_march(ray);
    
    calculate_coord_system(resolution, pixel, color);

    imageStore(output_image, ivec2(pixel), vec4(color, 1.0));

    // write to output pixel buffer
    uint pixel_index = pixel.y * resolution.x + pixel.x;
    output_pixel_data[pixel_index].col = color;
}
